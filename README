Pleajure.clj
By Anand Patil
February 20, 2009

Copyright (c) 2009 Anand Patil

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


 ===========
 = Purpose =
 ===========

Pleajure lets you write Clojure S-expressions using whitespace in place of parentheses. The resulting look-and-feel is a bit like Python.


 =================
 = Usage example =
 =================

(load-file "pleajure.clj")

Translate and display:
(pleajure-print "test.plj")

Translate and load (like load-file):
(pleajure-load "test.plj")


 =====================
 = Translation rules =
 =====================

1) Lines are listed S-expressions. That means

    a .....
    b .....

translates to 

    (a .....) (b .....)


2) Indented blocks are nested S-expressions. That means

    a ......
        b ......
            c ......
        d ......
        e ......

translates to 

    (a ...... (b ...... (c ......)) (d ......) (e ......))


3) Commas mean the next line is part of the current line. That means

    a ......
        b ......,
            ######
            c ......,
                ******
        d ......
        e ......

translates to

    (a ...... (b ......, ###### (c ......, ******)) (d ......) (e ......))


4) Lines that are part of strings and comments are left alone.


 ===================
 = Syntax examples =
 ===================

***********************************************************************

defn id? [x] 
    "Checks whether x is an id: ref, value or agent"
    or
        instance? clojure.lang.IRef x
        instance? clojure.lang.Agent x
        instance? clojure.proxy.java.util.concurrent.atomic.AtomicReference$IRef x
        
--------- translates to --------------

(defn id? [x]
    "Checks whether x is an id: ref, value or agent"
    (or
        (instance? clojure.lang.IRef x)
        (instance? clojure.lang.Agent x)
        (instance? clojure.proxy.java.util.concurrent.atomic.AtomicReference$IRef x)))
        
***********************************************************************

***********************************************************************

defn report-to-child [val parent agent-parents parents update-fn agent-parent-vals]
    "Called by parent-watcher when a parent either updates or reverts to
    the 'need-update' state. If a parent updates and the child cell wants
    to update, computation is performed if possible. If a parent reverts
    to the need-to-update state, the child is put into the need-to-update 
    state also."
    do (dosync (commute agent-parent-vals swap-agent-parent-value parent))
        if (:updating val) 
            if (= (count @agent-parent-vals) (count agent-parents)) ,
                (compute parents agent-parent-vals update-fn) ,
                val
            if (:needs-update val) ,
                val ,
                {:needs-update true}

--------- translates to --------------

(defn report-to-child [val parent agent-parents parents update-fn agent-parent-vals]
    "Called by parent-watcher when a parent either updates or reverts to
    the 'need-update' state. If a parent updates and the child cell wants
    to update, computation is performed if possible. If a parent reverts
    to the need-to-update state, the child is put into the need-to-update
    state also."
    (do (dosync (commute agent-parent-vals swap-agent-parent-value parent))
        (if (:updating val)
            (if (= (count @agent-parent-vals) (count agent-parents)) ,
                (compute parents agent-parent-vals update-fn) ,
                val)
            (if (:needs-update val) ,
                val ,
                {:needs-update true}))))

***********************************************************************


 ========
 = Note =
 ========

Pleajure is alpha. Expect some errors. If you want it to work better, fork it!